{-# Language OverloadedStrings #-}
{-# LANGUAGE GADTs #-}

module Coq where

import qualified Data.Map.Strict    as Map -- abandon in favor of [(a,b)]?
import Data.List.NonEmpty (toList)
import qualified Data.Text as T
import Data.List (intersperse)
import Data.Either (lefts, rights)

import EVM.ABI
import EVM.Solidity (SlotType(..))
import Syntax
import RefinedAst

type Store = Map.Map Id (Map.Map Id SlotType)

-- constants
indent = "  "
header = "(* GENERATED BY ACT *)\n\nRequire Import Arith.\n\n"
baseName = "BASE"

parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

forget :: Map.Map k a -> a
forget = snd . head . Map.toList

coq :: Store -> [Claim] -> T.Text
coq store claims =
  header
    <> cLayout store <> "\n"
    <> T.intercalate "\n" (map (cClaim store) claims)
    <> base store
    <> reachable claims

base :: Store -> T.Text
base store =
  "Definition " <> baseName <> " := state\n"
    <> error "TODO: base state"

reachable :: [Claim] -> T.Text
reachable claims =
  "Inductive reachable : State -> Prop :=\n"
    <> "| base : reachable BASE\n"
    <> T.intercalate "\n" (map reachableStep claims)
  where
    reachableStep claim = error "TODO: reachable steps"

cClaim :: Store -> Claim -> T.Text
cClaim _ (I _) = ""
cClaim store (B b@(Behaviour name mode creation _ interface _ _ _ _)) =
  case (mode, creation) of
    (Pass, False) -> "Definition "
      <> T.pack name
      <> " (s : State) "
      <> cInterface interface
      <> " :=\n"
      <> cBody store b
    (_, _) -> ""

cBody :: Store -> Behaviour -> T.Text
cBody store (Behaviour _ _ _ _ _ preconditions _ updates returns) =
  "match "
    <> parens (cBoolExp preconditions)
    <> " with\n| true => " <> cUpdates store updates
    <> "\n| false => s\nend.\n"

cUpdates :: Store -> [Either StorageLocation StorageUpdate] -> T.Text
cUpdates store updates =

  "state " <> T.intercalate " " (map (cUpdate (rights updates)) pairs) where

  cUpdate :: [StorageUpdate] -> (Id, SlotType) -> T.Text
  cUpdate updates (name, t) =
    case look name updates of
      Nothing -> parens $ T.pack name <> " s"
      Just e -> parens e
  look name ((IntUpdate (DirectInt _ name') e):_)
    | name == name' = Just $ cIntExp e
  look name ((BoolUpdate (DirectBool _ name') e):_)
    | name == name' = Just $ cBoolExp e
  look name (_:xs) = look name xs
  look name [] = Nothing
  -- TODO: remaining expressions
  pairs = Map.toList (forget store)

cInterface :: Interface -> T.Text
cInterface (Interface _ decls) =
  T.intercalate " " (map cDecl decls) where
  cDecl (Decl t name) = parens $ T.pack name <> " : " <> cAbiType t

cLayout :: Store -> T.Text
cLayout store =
  "Record State : Set := state\n" <> indent <> "{ "
    <> T.intercalate ("\n" <> indent <> "; ") (map cNamedType pairs)
    <> "\n" <> indent <> "}.\n" where
    pairs = Map.toList (forget store)

cNamedType :: (Id, SlotType) -> T.Text
cNamedType (name, slottype) = (T.pack name) <> " : " <> cType slottype

cType :: SlotType -> T.Text
cType (StorageMapping xs t) =
  T.intercalate " -> " (map cAbiType (toList xs ++ [t]))
cType (StorageValue abitype) = cAbiType abitype

cAbiType :: AbiType -> T.Text
cAbiType (AbiUIntType _) = "nat"
cAbiType (AbiIntType _) = error "TODO: signed integers"
cAbiType AbiAddressType = "address"
cAbiType AbiStringType = "string"
cAbiType a = error $ show a

defaultValue :: AbiType -> T.Text
defaultValue (AbiUIntType _) = "0"
defaultValue (AbiIntType _) = error "TODO: signed integer default"
defaultValue AbiAddressType = "0"
defaultValue AbiStringType = "EmptyString"
defaultValue a = error "TODO: missing default values"

cBoolExp :: Exp Bool -> T.Text
cBoolExp (LitBool True)  = "true"
cBoolExp (LitBool False) = "false"
cBoolExp (BoolVar name) = T.pack name -- TODO
cBoolExp (And e1 e2)  = parens $ "andb "   <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Or e1 e2)   = parens $ "orb"     <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Impl e1 e2) = parens $ "implb"   <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Eq e1 e2)   = parens $ "Nat.eqb" <> cIntExp e1  <> " " <> cIntExp e2
cBoolExp (NEq e1 e2)  = parens $ "negb " <> parens ("Nat.eqb" <> cIntExp e1  <> " " <> cIntExp e2)
cBoolExp (Neg e)      = parens $ "negb " <> cBoolExp e
cBoolExp (LE e1 e2)   = parens $ "Nat.ltb " <> cIntExp e1 <> " " <> cIntExp e2
cBoolExp (LEQ e1 e2)  = parens $ "Nat.leb " <> cIntExp e1 <> " " <> cIntExp e2
cBoolExp (GE e1 e2)   = parens $ "Nat.ltb " <> cIntExp e2 <> " " <> cIntExp e1
cBoolExp (GEQ e1 e2)  = parens $ "Nat.leb " <> cIntExp e2 <> " " <> cIntExp e1
cBoolExp a = error $ show a

cIntExp :: Exp Integer -> T.Text
cIntExp (LitInt i) = T.pack $ show i
cIntExp (IntVar name) = T.pack name -- TODO
cIntExp (Add e1 e2) = parens $ cIntExp e1 <> " + " <> cIntExp e2
cIntExp (TEntry (DirectInt _ name)) = parens $ T.pack name <> " s"
cIntExp a = error $ show a

