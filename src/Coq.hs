{-# Language OverloadedStrings #-}
{-# LANGUAGE GADTs #-}

module Coq where

import qualified Data.Map.Strict    as Map -- abandon in favor of [(a,b)]?
import Data.List.NonEmpty (toList)
import qualified Data.Text as T
import Data.List (intersperse)
import Data.Either (lefts, rights)
import Data.Maybe (mapMaybe)

import EVM.ABI
import EVM.Solidity (SlotType(..))
import Syntax
import RefinedAst

type Store = Map.Map Id (Map.Map Id SlotType)

-- constants
indent = "  "
header =
  "(* --- GENERATED BY ACT --- *)\n\n\
  \Require Import Coq.ZArith.ZArith.\n\
  \Require Coq.Strings.String.\n\
  \Module Str := Coq.Strings.String.\n\
  \Open Scope Z_scope.\n\n\
  \Definition address := Z.\n\n"
baseName = "BASE"

parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

headval :: Map.Map k a -> a
headval = snd . head . Map.toList

coq :: Store -> [Claim] -> T.Text
coq store claims =
  case mapMaybe isConstructor claims of
    [c] -> header
      <> cLayout store <> "\n"
      <> T.intercalate "\n" (map (cClaim store) claims)
      <> base store c <> "\n\n"
      <> reachable claims
    _ -> error "multiple constructors not supported"
  where
    isConstructor (B b) | (_creation b) && (_mode b == Pass) = Just b
    isConstructor _ = Nothing

base :: Store -> Behaviour -> T.Text
base store constructor =
  "Definition " <> baseName <> " :=\n" <> indent
    <> cUpdates store (\n t -> defaultValue t) (_stateUpdates constructor)
    <> "\n."

reachable :: [Claim] -> T.Text
reachable claims =
  "Inductive reachable : State -> Prop :=\n"
    <> "| base : reachable BASE\n"
    <> T.intercalate "\n" (map reachableStep claims)
    <> "\n.\n"
  where
    reachableStep (B b) | _mode b == Pass && not (_creation b) =
      "| " <> T.pack (_name b)
      <> "_step : forall (s : State) "
      <> cInterface (_interface b)
      <> ", reachable s -> reachable ("
      <> T.pack (_name b)
      <> " s " <> arguments (_interface b) <> ")"
    reachableStep _ = ""
    arguments (Interface _ decls) =
      T.intercalate " " (map (\(Decl _ name) -> T.pack name) decls)

cClaim :: Store -> Claim -> T.Text
cClaim store (B b@(Behaviour name mode creation _ interface _ _ _ _)) =
  case (mode, creation) of
    (Pass, False) -> "Definition "
      <> T.pack name
      <> " (s : State) "
      <> cInterface interface
      <> " :=\n"
      <> cBody store b
    (_, _) -> ""
cClaim _ _ = ""

cBody :: Store -> Behaviour -> T.Text
cBody store (Behaviour _ _ _ _ _ preconditions _ updates returns) =
  "match "
    <> parens (cBoolExp preconditions)
    <> " with\n| true => "
    <> cUpdates store (\n t -> T.pack n <> " s") updates
    <> "\n| false => s\nend.\n"

cUpdates
  :: Store
  -> (Id -> SlotType -> T.Text)
  -> [Either StorageLocation StorageUpdate]
  -> T.Text
cUpdates store handler updates =

  "state " <> T.intercalate " " (map (cUpdate (rights updates)) pairs) where

  cUpdate :: [StorageUpdate] -> (Id, SlotType) -> T.Text
  cUpdate updates (name, t) =
    case look name updates of
      Nothing -> parens $ handler name t
      Just e -> parens e
  look name ((IntUpdate (DirectInt _ name') e):_)
    | name == name' = Just $ cIntExp e
  look name ((BoolUpdate (DirectBool _ name') e):_)
    | name == name' = Just $ cBoolExp e
  look name (_:xs) = look name xs
  look name [] = Nothing
  -- TODO: remaining expressions
  pairs = Map.toList (headval store)

cInterface :: Interface -> T.Text
cInterface (Interface _ decls) =
  T.intercalate " " (map cDecl decls) where
  cDecl (Decl t name) = parens $ T.pack name <> " : " <> cAbiType t

cLayout :: Store -> T.Text
cLayout store =
  "Record State : Set := state\n" <> indent <> "{ "
    <> T.intercalate ("\n" <> indent <> "; ") (map cNamedType pairs)
    <> "\n" <> indent <> "}.\n" where
    pairs = Map.toList (headval store)

cNamedType :: (Id, SlotType) -> T.Text
cNamedType (name, slottype) = (T.pack name) <> " : " <> cType slottype

cType :: SlotType -> T.Text
cType (StorageMapping xs t) =
  T.intercalate " -> " (map cAbiType (toList xs ++ [t]))
cType (StorageValue abitype) = cAbiType abitype

cAbiType :: AbiType -> T.Text
cAbiType (AbiUIntType _) = "Z"
cAbiType (AbiIntType _) = "Z"
cAbiType AbiAddressType = "address"
cAbiType AbiStringType = "Str.string"
cAbiType a = error $ show a

defaultValue :: SlotType -> T.Text
defaultValue (StorageMapping xs t) = "fun "
  <> T.intercalate " " (replicate (length (toList xs)) "_")
  <> " => "
  <> abiVal t where
defaultValue (StorageValue t) = abiVal t

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = "Str.EmptyString"
abiVal a = error "TODO: missing default values"

cBoolExp :: Exp Bool -> T.Text
cBoolExp (LitBool True)  = "true"
cBoolExp (LitBool False) = "false"
cBoolExp (BoolVar name) = T.pack name -- TODO
cBoolExp (And e1 e2)  = parens $ "andb "   <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Or e1 e2)   = parens $ "orb"     <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Impl e1 e2) = parens $ "implb"   <> cBoolExp e1 <> " " <> cBoolExp e2
cBoolExp (Eq e1 e2)   = parens $ cIntExp e1  <> " =? " <> cIntExp e2
cBoolExp (NEq e1 e2)  = parens $ "negb " <> parens (cIntExp e1  <> " =? " <> cIntExp e2)
cBoolExp (Neg e)      = parens $ "negb " <> cBoolExp e
cBoolExp (LE e1 e2)   = parens $ cIntExp e1 <> " <? "  <> cIntExp e2
cBoolExp (LEQ e1 e2)  = parens $ cIntExp e1 <> " <=? " <> cIntExp e2
cBoolExp (GE e1 e2)   = parens $ cIntExp e2 <> " <? "  <> cIntExp e1
cBoolExp (GEQ e1 e2)  = parens $ cIntExp e2 <> " <?= " <> cIntExp e1
cBoolExp a = error $ show a

cIntExp :: Exp Integer -> T.Text
cIntExp (LitInt i) = T.pack $ show i
cIntExp (IntVar name) = T.pack name -- TODO
cIntExp (Add e1 e2) = parens $ cIntExp e1 <> " + " <> cIntExp e2
cIntExp (TEntry (DirectInt _ name)) = parens $ T.pack name <> " s"
cIntExp a = error $ show a

