comment "//" ;
comment "/*" "*/" ;

Main. Act ::= [Behaviour] ;

--TODO: support for `where` sublanguage
--TODO: tx environment variables (CALLER, NUMBER, TIMESTAMP...)
Transition. Behaviour ::= "behaviour" Var "of" Var
                          "interface" Var "(" [Decl] ")"
                          [IffH]
                          PostCond ;

-- our variables can start with underscores
token Var ((letter | '_')(letter | digit | '_')*) ;

CaseSplit. PostCond ::= [CaseExpr] ;
Direct. PostCond    ::= Post ;
Case. CaseExpr ::= "case" Exp ":"
                   PostCond ;

-- Behaviour either specify a state transition, a return value,
-- or both
StorageP. Post ::= [Storage] ;
ReturnP.  Post ::= "returns" Exp ;
StorageReturnP. Post ::= [Storage]
                        "returns" Exp ;

--storage headers of this contract
ThisStorage. Storage ::= "storage"
                         StorageH ;
CreatesThis. Storage ::= "creates" Var
                         [Assign] ;

--external storage headers
ExtStorage. Storage ::= "storage" "at" Exp
                        StorageH ;
CreatesExt. Storage ::= "creates" Var "at" Exp
                        [Assign] ;

--Storage headers and return headers may branch into cases:
Leaf. StorageH ::= [Update] ;
NoopLeaf. StorageH ::= "noop" ;


--assignments types storage variables
Assignval. Assign ::= Type Var ":=" Exp ;
Assignmap. Assign ::= Type Var ":=" "[" [Defn] "]" ;

Iff.   IffH ::= "iff" [Exp] ;
IffIn. IffH ::= "iff in range" Type "\n" [Exp] ;

-- New, concise syntax
Change. Update ::= Exp "=>" Exp ;

--Array expressions (list or maps)
Let. Defn ::= Exp ":=" Exp ;

--Boolean expressions
BAnd.  Exp  ::= Exp "and" Exp ;
BOr.   Exp  ::= Exp "or" Exp ;
BImpl. Exp  ::= Exp "=>" Exp ;
BEq.   Exp  ::= Exp "==" Exp ;
BNeq.  Exp  ::= Exp "=/=" Exp ;
BLEQ.  Exp  ::= Exp "<=" Exp ;
BLE.   Exp  ::= Exp "<" Exp ;
BGEQ.  Exp  ::= Exp ">=" Exp ;
BGE.   Exp  ::= Exp ">" Exp ;
_.     Exp  ::= "(" Exp ")" ;
BTrue. Exp  ::= "true" ;
BFalse. Exp ::= "false" ;
BWildcard. Exp ::= "_";

--todo: precedence
--Integer expressions
EAdd. Exp ::= Exp  "+" Exp ;
ESub. Exp ::= Exp  "-" Exp ;
_.    Exp ::= "(" Exp ")" ;
ITE.  Exp ::= "if" Exp "then" Exp "else" Exp ;
EMul. Exp ::= Exp "*" Exp ;
EDiv. Exp ::= Exp "/" Exp ;
EMod. Exp ::= Exp "%" Exp ;
EExp. Exp ::= Exp "^" Exp ;
Wild. Exp ::= "_" ;
Zoom. Exp ::= Exp "." Var ;
Func. Exp ::= Var "(" [Exp] ")" ;
-- lookups
Look. Exp ::= Exp "[" Exp "]" ;
--Bytes expressions
Cat.   Exp ::= Exp "++" Exp ;
Slice. Exp ::= Exp "[" Integer ".." Integer "]" ;
--built in functions
Newaddr.  Exp ::= "newAddr" "(" Exp "," Exp ")";
Newaddr2. Exp ::= "newAddr" "(" Exp "," Exp "," Exp ")";
BYHash.   Exp ::= "keccak256" "(" Exp ")";
BYAbiE.   Exp ::= "abiEncode" "(" Exp ")";
-- terminals
StringLit. Exp ::= String ;
VarLit.    Exp ::= Var ;
IntLit.    Exp ::= Integer ;

Dec. Decl ::= Type Var ;

--more todo obv
rules Type ::= "uint"    | "int"
             | "uint256" | "int256"
             | "uint126" | "int126"
             | "uint8"   | "int8"
             | "address" | "bytes"
             | "bytes32" | "bytes4"
             | "bool"    | "string" ;
ArrayType.   Type ::= Type "[" Integer "]" ;
MappingType. Type ::= "mapping" "(" Type "=>" Type ")" ;
TupleType.   Type ::= "(" [Type] ")" ;
Contract.    Type ::= Var ;

--fragments of where language
Fun. FuncDef ::= Var "(" [Var] ")" "=" Exp ;

separator Var "," ;
separator Decl "," ;
separator Exp "," ;
separator IffH "" ;
separator nonempty Storage "" ;
separator Assign "" ;
separator Type "," ;
separator Defn "," ;
separator nonempty Behaviour "" ;
separator nonempty CaseExpr "" ;
separator nonempty FuncDef "" ;
separator nonempty Exp "" ;
separator nonempty Update "" ;
