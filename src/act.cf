comment "//" ;
comment "/*" "*/" ;

Main. Act ::= [Behaviour] ;

--TODO: support for `where` sublanguage
--TODO: tx environment variables (CALLER, NUMBER, TIMESTAMP...)
-- Behaviour either specify a state transition, a return value,
-- or both
Transition. Behaviour ::= "behaviour" Ident "of" Ident
                          "interface" Ident "(" [Decl] ")"
                          [IffH]
                          PostCond ;

CaseSplit. PostCond ::= [CaseExpr] ;
Direct. PostCond    ::= Post ; 
Case. CaseExpr ::= "case" BExp ":" PostCond ;
StorageP. Post ::= [Storage] ;
ReturnP.  Post ::= "returns" Exp ;
StorageReturnP. Post ::= [Storage]
                        "returns" IExp ;

--storage headers of this contract
ThisStorage. Storage ::= "storage" StorageH ;
CreatesThis. Storage ::= "creates" Ident [Assign] ;

--external storage headers
ExtStorage. Storage ::= "storage" IExp StorageH ;
CreatesExt. Storage ::= "creates" Ident "at" IExp [Assign] ;

--Storage headers and return headers may branch into cases:
Leaf. StorageH ::= [Update] ;
NoopLeaf. StorageH ::= "noop" ;

--assignments types storage variables
Assignm. Assign ::= Type Ident ":=" Exp ;

Iff.   IffH ::= "iff" [BExp] ;
IffIn. IffH ::= "iff in range" Type "\n" [IExp] ;

-- New, concise syntax
Change. Update ::= Entry "=>" IExp ;

Map.    Entry ::= Ident [Lookup] ; --Empty lookup map is a constant storage var
Struct. Entry ::= Entry "." Ident ;

Look. Lookup ::= "[" Exp "]" ;

--Any expression
Int.   Exp ::= IExp ;
Bool.  Exp ::= BExp ;
Bytes. Exp ::= BYExp ;

--Boolean expressions
--TODO: precedence
BAnd.  BExp  ::= BExp "and" BExp ;
BOr.   BExp  ::= BExp "or" BExp ;
BImpl. BExp  ::= BExp "=>" BExp ;
BEq.   BExp  ::= IExp "==" IExp ;
BNeq.  BExp  ::= IExp "=/=" IExp ;
BLEQ.  BExp  ::= IExp "<=" IExp ;
BLE.   BExp  ::= IExp "<" IExp ;
BGEQ.  BExp  ::= IExp ">=" IExp ;
BGE.   BExp  ::= IExp ">" IExp ;
_.     BExp  ::= "(" BExp ")" ;
BTrue. BExp  ::= "true" ;
BFalse. BExp ::= "false" ;
BWildcard. BExp ::= "_";
BFunc. BExp  ::= Ident "(" [Exp] ")" ;


--Integer expressions
EAdd. IExp  ::= IExp  "+" IExp1 ;
ESub. IExp  ::= IExp  "-" IExp1 ;
Addr. IExp  ::= "newAddr" "(" IExp "," IExp ")" ;
_.    IExp  ::= "(" IExp ")" ;
ITE.  IExp  ::= "if" BExp "then" IExp "else" IExp ;
EMul. IExp1 ::= IExp1 "*" IExp2 ;
EDiv. IExp1 ::= IExp1 "/" IExp2 ;
EMod. IExp1 ::= IExp1 "%" IExp2 ;
EExp. IExp1 ::= IExp1 "^" IExp2 ;
Wild. IExp2 ::= "_" ;
EVar. IExp2 ::= Ident ;
EInt. IExp2 ::= Integer ;
IFunc. IExp  ::= Ident "(" [Exp] ")" ;

--Bytes expressions
BYAdd.  BYExp  ::= BYExp "++" BYExp ;
BYFunc. BYExp  ::= Ident "(" [Exp] ")" ;
BYLit.  BYExp2  ::= String ;
BYVar.  BYExp2  ::= Ident ;
_.  BYExp3  ::= "(" BYExp ")" ;
Slice.  BYExp  ::= BYExp "[" Integer ".." Integer "]" ;
--built in functions
BYHash. BYExp  ::= "keccak256" "(" Exp ")";
BYAbiE. BYExp  ::= "abiEncode" "(" Exp ")";

coercions IExp 2 ;
coercions BYExp 3 ;

Dec. Decl ::= Type Ident ;

Fun. FuncDef ::= Ident "(" [Ident] ")" "=" Exp ;

--more todo obv
rules Type ::= "uint"    | "int" 
             | "uint256" | "int256"
             | "uint126" | "int126"
             | "uint8"   | "int8"
             | "address" | "bytes"
             | "bytes32" | "bytes4"
             | "bool" ;
ArrayType. Type ::= Type Length ;
TupleType. Type ::= "(" [Type] ")" ;

Contr. Type ::= Ident ;

Index. Length ::= "[" Integer "]" ;

separator Ident "," ;
separator Decl "," ;
separator Exp "," ;
separator IffH "" ;
separator Storage "" ;
separator Assign "" ;
separator Type "," ;
separator nonempty Behaviour "" ;
separator nonempty CaseExpr "" ;
separator nonempty FuncDef "" ;
separator Lookup "" ;
separator nonempty BExp "" ;
separator nonempty IExp "" ;
separator nonempty Update "" ;
-- terminator Header "End" ;

