comment "//" ;
comment "/*" "*/" ;

Main. Act ::= [Behaviour] ;

--TODO: support for `where` sublanguage

-- Behaviour either specify a state transition, a return value,
-- or both
Transition. Behaviour ::= "behaviour" Ident "of" Ident
                          "interface" Ident "(" [Decl] ")"
                          [IffH]
                          "storage"
                          StorageH ;

Returns. Behaviour ::= "behaviour" Ident "of" Ident
                     "interface" Ident "(" [Decl] ")"
                     [IffH]
                     ReturnH ;

TransReturn. Behaviour ::= "behaviour" Ident "of" Ident
                          "interface" Ident "(" [Decl] ")"
                          [IffH]
                          "storage"
                          StorageH
                          ReturnH ;

Iff.   IffH ::= "iff" [BExp] ;
IffIn. IffH ::= "iff in range" Type "\n" [IExp] ;

--Storage headers and return headers may branch into cases:
Leaf. StorageH ::= [Update] ;
NoopLeaf. StorageH ::= "noop" ; 
Case. CaseExpr ::= "case" BExp ":" StorageH ;
Branch. StorageH ::= [CaseExpr] ;

-- New, concise syntax
Change. Update ::= Storage "=>" IExp ;

Map.    Storage ::= Ident [Lookup] ; --Empty lookup map is a constant storage var
Struct. Storage ::= Storage "." Ident ;

Look. Lookup ::= "[" Exp "]" ;

Return. ReturnH ::= "returns" IExp  ;

--Any expression
Int.   Exp ::= IExp ;
Bool.  Exp ::= BExp ;
Bytes. Exp ::= BYExp ;

--Boolean expressions
--TODO: precedence
BAnd. BExp   ::= BExp "and" BExp ;
BOr. BExp    ::= BExp "or" BExp ;
BImpl. BExp  ::= BExp "=>" BExp ;
BEq. BExp    ::= IExp "==" IExp ;
BNeq. BExp   ::= IExp "=/=" IExp ;
BLEQ. BExp   ::= IExp "<=" IExp ;
BLE. BExp    ::= IExp "<" IExp ;
BGEQ. BExp   ::= IExp ">=" IExp ;
BGE. BExp    ::= IExp ">" IExp ;
_. BExp      ::= "(" BExp ")" ;
BTrue. BExp  ::= "true" ;
BFalse. BExp ::= "false" ;
BWildcard. BExp ::= "_";
BFunc. BExp  ::= Ident "(" [Exp] ")" ;

--Integer expressions
EAdd. IExp  ::= IExp  "+" IExp1 ;
ESub. IExp  ::= IExp  "-" IExp1 ;
_.    IExp  ::= "(" IExp ")" ;
ITE.  IExp  ::= "if" BExp "then" IExp "else" IExp ;
EMul. IExp1 ::= IExp1 "*" IExp2 ;
EDiv. IExp1 ::= IExp1 "/" IExp2 ;
EMod. IExp1 ::= IExp1 "%" IExp2 ;
EExp. IExp1 ::= IExp1 "^" IExp2 ;
Wild. IExp2 ::= "_" ;
EVar. IExp2 ::= Ident ;
EInt. IExp2 ::= Integer ;
StorageVar. IExp2 ::= Storage ;
IFunc. IExp  ::= Ident "(" [Exp] ")" ;

--Bytes expressions
BYAdd.  BYExp  ::= BYExp "++" BYExp ;
BYFunc. BYExp  ::= Ident "(" [Exp] ")" ;
BYLit.  BYExp2  ::= String ;
BYVar.  BYExp2  ::= Ident ;
Paren.  BYExp3  ::= "(" BYExp ")" ;
Slice.  BYExp  ::= BYExp "[" Integer ".." Integer "]" ;

coercions IExp 2 ;
coercions BYExp 3 ;

Dec. Decl ::= Type Ident ;
TDec. TDecl ::= Ident ":" Type ;

Fun. FuncDef ::= Ident "(" [Ident] ")" "=" Exp ;

rules Type ::= "uint"    | "int"
             | "bytes" Length
             | "bytes"
             | "uint256" | "int256"
             | "uint126" | "int126"
             | "uint8"   | "int8"
             | "address"
             | "bytes32"
             | "bool" ;

Index. Length ::= "[" Integer "]" ;

separator Ident "," ;
separator Decl "," ;
separator Exp "," ;
separator IffH "" ;
separator Behaviour "" ;
separator CaseExpr "" ;
separator nonempty TDecl "" ;
separator nonempty FuncDef "" ;
separator Lookup "" ;
separator nonempty BExp "" ;
separator nonempty IExp "" ;
separator nonempty Update "" ;
-- separator nonempty Header "" ;
-- terminator Header "End" ;

