comment "//" ;
comment "/*" "*/" ;

Main. Act ::= [Behaviour] ;

--TODO: support for `where` sublanguage
--TODO: tx environment variables (CALLER, NUMBER, TIMESTAMP...)
-- Behaviour either specify a state transition, a return value,
-- or both
Transition. Behaviour ::= "behaviour" Var "of" Var
                          "interface" Var "(" [Decl] ")"
                          [IffH]
                          PostCond ;

-- our variables can start with underscores
token Var ((letter | '_')(letter | digit | '_')*) ;

CaseSplit. PostCond ::= [CaseExpr] ;
Direct. PostCond    ::= Post ; 
Case. CaseExpr ::= "case" BExp ":" PostCond ;
StorageP. Post ::= [Storage] ;
ReturnP.  Post ::= "returns" Exp ;
StorageReturnP. Post ::= [Storage]
                        "returns" IExp ;

--storage headers of this contract
ThisStorage. Storage ::= "storage" StorageH ;
CreatesThis. Storage ::= "creates" Var [Assign] ;


--external storage headers
ExtStorage. Storage ::= "storage" IExp StorageH ;
CreatesExt. Storage ::= "creates" Var "at" IExp [Assign] ;

--Storage headers and return headers may branch into cases:
Leaf. StorageH ::= [Update] ;
NoopLeaf. StorageH ::= "noop" ;


--assignments types storage variables
Assignm. Assign ::= Type Var ":=" Exp ;

Iff.   IffH ::= "iff" [BExp] ;
IffIn. IffH ::= "iff in range" Type "\n" [IExp] ;

-- New, concise syntax
Change. Update ::= Entry "=>" IExp ;

VarEntry.   Entry ::= Var ;
ArrayEntry. Entry ::= Entry "[" Exp "]" ;
Struct.     Entry ::= Entry "." Var ;

--Any expression
Int.   Exp ::= IExp ;
Bool.  Exp ::= BExp ;
Bytes. Exp ::= BYExp ;
Array. Exp ::= "[" [Defn]"]" ;

--Boolean expressions
--TODO: precedence
BAnd.  BExp  ::= BExp "and" BExp ;
BOr.   BExp  ::= BExp "or" BExp ;
BImpl. BExp  ::= BExp "=>" BExp ;
BEq.   BExp  ::= IExp "==" IExp ;
BNeq.  BExp  ::= IExp "=/=" IExp ;
BLEQ.  BExp  ::= IExp "<=" IExp ;
BLE.   BExp  ::= IExp "<" IExp ;
BGEQ.  BExp  ::= IExp ">=" IExp ;
BGE.   BExp  ::= IExp ">" IExp ;
_.     BExp  ::= "(" BExp ")" ;
BTrue. BExp  ::= "true" ;
BFalse. BExp ::= "false" ;
BWildcard. BExp ::= "_";
BFunc. BExp  ::= Var "(" [Exp] ")" ;

--Array expressions (list or maps)
Let. Defn ::= Exp ":=" Exp ;

--Integer expressions
EAdd. IExp  ::= IExp  "+" IExp1 ;
ESub. IExp  ::= IExp  "-" IExp1 ;
Addr. IExp  ::= "newAddr" "(" IExp "," IExp ")" ;
_.    IExp  ::= "(" IExp ")" ;
ITE.  IExp  ::= "if" BExp "then" IExp "else" IExp ;
EMul. IExp1 ::= IExp1 "*" IExp2 ;
EDiv. IExp1 ::= IExp1 "/" IExp2 ;
EMod. IExp1 ::= IExp1 "%" IExp2 ;
EExp. IExp1 ::= IExp1 "^" IExp2 ;
Wild. IExp2 ::= "_" ;
EVar. IExp2 ::= Entry ;
EInt. IExp2 ::= Integer ;
IFunc. IExp  ::= Var "(" [Exp] ")" ;

--Bytes expressions
BYAdd.  BYExp  ::= BYExp "++" BYExp ;
BYFunc. BYExp  ::= Var "(" [Exp] ")" ;
BYLit.  BYExp2  ::= String ;
BYVar.  BYExp2  ::= Var ;
_.  BYExp3  ::= "(" BYExp ")" ;
Slice.  BYExp  ::= BYExp "[" Integer ".." Integer "]" ;
--built in functions
BYHash. BYExp  ::= "keccak256" "(" Exp ")";
BYAbiE. BYExp  ::= "abiEncode" "(" Exp ")";

coercions IExp 2 ;
coercions BYExp 3 ;

Dec. Decl ::= Type Var ;

Fun. FuncDef ::= Var "(" [Var] ")" "=" Exp ;

--more todo obv
rules Type ::= "uint"    | "int" 
             | "uint256" | "int256"
             | "uint126" | "int126"
             | "uint8"   | "int8"
             | "address" | "bytes"
             | "bytes32" | "bytes4"
             | "bool"    | "string" ;
ArrayType.   Type ::= Type "[" Integer "]" ;
MappingType. Type ::= "mapping" "(" Type "=>" Type ")" ;
TupleType.   Type ::= "(" [Type] ")" ;
Contract.    Type ::= Var ;

separator Var "," ;
separator Decl "," ;
separator Exp "," ;
separator IffH "" ;
separator Storage "" ;
separator Assign "" ;
separator Type "," ;
separator Defn "," ;
separator nonempty Behaviour "" ;
separator nonempty CaseExpr "" ;
separator nonempty FuncDef "" ;
separator nonempty BExp "" ;
separator nonempty IExp "" ;
separator nonempty Update "" ;
-- terminator Header "End" ;

